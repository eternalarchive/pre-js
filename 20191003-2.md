# 6. 연산자

### 1. 표현식과 연산자

- 프로그래밍 언어에서 표현식은 대단히 중요한 의미
- 표현식(expression) : 리터럴, 식별자, 연산자, 함수 호출 등(이들을 토큰이라 함)의 조합
  - 표현식은 하나의 값으로 평가될수 있는 문
- 표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식등으로 나누어 볼 수 있지만 결국 평가되어 하나의 값을 만든다는 점에서 모두 동일

![](https://poiemaweb.com/assets/fs-images/6-1.png)

- 표현식은 평가되어 결국 하나의 값이 되므로 표현식과 표현식이 평가되어 생성된 값은 동등한 관계
  - 표현식 = 표현식이 평가되어 생성된 값 -> 동치(Equivalent)
  - 표현식은 값처럼 사용할 수 있음
- 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있음
  - 산술 연산자 +의 좌항과 우항에는 숫자 값이 위치해야 하는데, 숫자 값으로 평가될 수 있는 표현식이라면 숫자 값대신 사용 가능

```javascript
var x = 10;

// 표현식 x + 30은 식별자 표현식과 숫자 리터럴과 연산자의 조합으로 구성되어 있다.
x + 30; // -> 40
```

- 연산자 표현식은 표현식을 결합해 새로운 값을 만들어내는 가장 일반적인 표현식



### 2. 문과 표현식

- 문(statement) : 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령
  - 문이 실행되면 명령이 실행되고 무슨 일인가가 일어남
  - 문의 집합으로 이루어진 것이 프로그램이며 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍
  - 선언문, 표현식 문, 조건문, 반복문 등으로 구분 가능
  - 문은 세미콜론으로 끝나야 하나 코드블록 {...} 뒤에는 세미콜론을 붙이지 않음

![](https://poiemaweb.com/assets/fs-images/6-2.png)

- 자바스크립트의 모든 코드는 문 또는 표현식
  - 자연어에서 문이 마침표로 끝나는 하나의 완전한 문장(sectence), 표현식은 문을 구성하는 구(phrase)같은 요소
  - 표현식은 그 자체로 문이 될 수 있지만 문이 표현식이 될 수는 없음
- 표현식은 문과 유사하여 구별이 어려울 수 있음
  - 표현식은 평과되어 값을 만들지만 그 이상의 행위는 불가능
  - 문은 선언문과 같이 선언 키워드를 사용하여 변수나 함수, 클래스를 생성하기도 하고 제어문을 생성하여 프로그램의 흐름을 제어하기도 함
- **표현식의 역할은 값을 생성하는 것**
- **문의 역할은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령을 내리는 것**



### 3. 표현식인 문과 표현식이 아닌 문

- 표현식인 문 : 값으로 평가될 수 있는 문
  - 예) 할당문
- 표현식이 아닌 문 : 값으로 평가될 수 없는 문
  - 예) 변수 선언문
- 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생

```javascript
// 변수 선언문은 표현식이 아닌 문이다.
var x ;

// 할당문 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 100

// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var

// 표현식인 문은 값처럼 사용할 수 있다
var foo = x = 100;
console.log(foo); // 100
```

- 완료 값(Completion valus) : 크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력하는데 이를 완료 값이라 함
  - 완료 값은 다른 값과 같이 변수에 할당할 수 없음

```javascript
// 표현식이 아닌 문은 완료 값 undefined를 반환한다.
var foo = 10; // undefined

// 조건문
if (true) {} // undefined
```

- 표현식인 문은 언제나 평가된 값 출력

```javascript
var num = 10; // undefined

// 표현식은 평가된 값을 반환한다.
// 표현식 문
100 + num; // 110

// 할당문
num = 100; // 100
```



### 4. 연산자란?

- 연산자(Operator) : 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만드는 것
  - 피연산자(Operand) : 연산의 대상, 피연산자도 평가되어 하나의 값이 되므로 표현식이고 피연산자를 연산자와 결합한 연산자 표현식도 물론 표현식

```javascript
// 표현식이 아닌 문은 완료 값 undefined를 반환한다.
// 변수 선언문
var foo = 10; // undefined

// 조건문
if (true) {} // undefined
```

- 피연산자가 '값'이라는 명사의 역할을 한다면 연산자는 '피연산자를 연산하여 새로운 값을 만든다'라는 동사의 역할
- 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 함
- 연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만듦



### 5. 산술 연산자

- 산술 연산자(Arithmetic Operator) : 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듦
  - 산술 연산이 불가능한 경우 NaN반환
- 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분



#### 5.1 이항 산술 연산자

- 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든 것
- 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과(Side effect)가 없으므로 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없음
  - 언제나 새로운 값을 만들 뿐

```javascript
5 + 2; // -> 7
5 - 2; // -> 3
5 * 2; // -> 10
5 / 2; // -> 2.5
5 % 2; // -> 1
```



#### 5.2 단항 산술 연산자

- 단항(Unary) 산술 연산자 : 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만듦
- 이항 산술 연산자와는 달리 증가/감소 연산자는 피연순자의 값을 변경하는 부수 효과가 있으므로 증가/감소 연산시 피연산자의 값이 바뀜

| 단항 산술 연산자 | 의미                                                  | 부수 효과 |
| ---------------- | ----------------------------------------------------- | --------- |
| ++               | 증가                                                  | O         |
| --               | 감소                                                  | O         |
| +                | 어떠한 효과도 없다. 음수를 양수로 반전 하지도 않는다. | X         |
| -                | 양수를 음수로 음수를 양수로 반전한 값을 반환한다.     | X         |

- 증가/감소 연산자는 위치에 의미가 있음
  - 피연산자 앞에 위치한 전위 증가/감소 연산자(Prefix increment/decrement operator)는 먼저 피연산자의 값을 증가/감소 시킨 후, 다른 연산 수행
  - 피연산자 뒤에 위치한 후위 증가/감소 연산자(Postfix increment/decrement operator)는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소

```javascript
var x = 5, result;

// 선할당 후증가 (Postfix increment operator)
result = x++;
console.log(result, x); // 5 6

// 선증가 후할당 (Prefix increment operator)
result = ++x;
console.log(result, x); // 7 7

// 선할당 후감소 (Postfix decrement operator)
result = x--;
console.log(result, x); // 7 6

// 선감소 후할당 (Prefix decrement operator)
result = --x;
console.log(result, x); // 5 5
```

- +단항 연산자는 피연산자에 어떠한 효과도 없으나 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환
  - 이 때 피연산자를 변경하는게 아니라 숫자 타입으로 변환한 값을 생성하여 반환하므로 부수 효과는 없음

```javascript
// 아무런 효과가 없다.
+10;    // -> 10
+(-10); // -> -10

// 문자열을 숫자로 타입 변환한다.
+'10'; // -> 10

// 불리언 값을 숫자로 타입 변환한다.
+true; // -> 1

// 불리언 값을 숫자로 타입 변환한다.
+false; // -> 0

// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
+'Hello'; // -> NaN
```

- -단항 연산자는 피연산자의 부호를 반전한 값을 반환하는데. +단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환
  - 피연산자를 변경하지 않고 부호를 반전한 값을 생성하여 반환하여 부수 효과는 없음

```javascript
// 부호를 반전한다.
-(-10); // -> 10

// 문자열을 숫자로 타입 변환한다.
-'10'; // -> -10

// 불리언 값을 숫자로 타입 변환한다.
-true; // -> -1

// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
-'Hello'; // -> NaN
```



#### 5.3 문자열 연결 연산자

- +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작

```javascript
// 문자열 연결 연산자
'1' + 2; // -> '12'
1 + '2'; // -> '12'

// 산술 연산자
1 + 2; // -> 3

// true는 1로 타입 변환된다.
1 + true; // -> 2

// false는 0으로 타입 변환된다.
1 + false; // -> 1

// null는 0으로 타입 변환된다.
1 + null; // -> 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined;    // -> NaN
1 + undefined; // -> NaN
```

- 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 경우
  - 위 예제에서 1 + true 연산시 자바스크립트 엔진은 암묵적으로 불리언 타입값인 true를 숫자 타입인 1로 강제 변환 후 연산 수행
  - 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 함
    - 앞서 살펴본 +/- 단항 연산자도 암묵적 타입 변환이 발생한 것



### 6. 할당 연산자

- 할당 연산자(Assignment Operator) : 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당
  - 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과 발생

| 할당 연산자 | 사례   | 동일 표현 | 부수 효과 |
| ----------- | ------ | --------- | --------- |
| =           | x = 5  | x = 5     | O         |
| +=          | x += 5 | x = x + 5 | O         |
| -=          | x -= 5 | x = x - 5 | O         |
| *=          | x *= 5 | x = x * 5 | O         |
| /=          | x /= 5 | x = x / 5 | O         |
| %=          | x %= 5 | x = x % 5 | O         |

```javascript
var str = 'My name is ';

// 문자열 연결 연산자
str += 'Lee'; // str = str + 'Lee';

console.log(str); // 'My name is Lee'
```

- 표현식은 하나의 값으로 평가된다고 하였는데, 할당 연산은 표현식인 문일까?
  - 할당 연산은 하나의 값으로 평가되는 표현식
  - 할당 표현식은 할당된 값으로 평가
  - 할당 연산 표현식을 다른 변수에 할당할 수도 있으므로 여러 변수에 동일한 값을 연쇄 할당할 수 있음

```javascript
var x;

// 할당문은 표현식인 문이다.
console.log(x = 10); // 10

// 연쇄 할당
var a, b, c;

// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.
// ① c = 0 : 0으로 평가된다
// ② b = 0 : 0으로 평가된다
// ③ a = 0 : 0으로 평가된다
a = b = c = 0;

console.log(a, b, c); // 0 0 0
```



### 7. 비교 연산자

- 비교 연산자(Comparison Operator) : 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환
  - if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용

#### 7.1 동등 / 일치 비교 연산자

- 동등 비교(loose equality) 연산자와 일치 비교(strict equality) 연산자는 좌항과 우항의 피연산자가 같은 값을 갖는지 비교하여 불리언 값 반환
  - 엄격성의 정도가 다름
  - 동등 비교 연산자는 느슨한 비교 / 일치 비교 연산자는 엄격한 비교

| 비교 연산자 | 의미        | 사례    | 설명                     | 부수 효과 |
| ----------- | ----------- | ------- | ------------------------ | --------- |
| ==          | 동등 비교   | x == y  | x와 y의 값이 같음        | X         |
| ===         | 일치 비교   | x === y | x와 y의 값과 타입이 같음 | X         |
| !=          | 부동등 비교 | x != y  | x와 y의 값이 다름        | X         |
| !==         | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 | X         |

- 동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값을 갖는지 비교
  - 타입은 다르더라도 암묵적 타입 변환 후 같은 값이면 true 반환

```javascript
// 동등 비교
5 == 5; // -> true

// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.
5 == '5'; // -> true
```

- 동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵기 때문에 부작용을 일으킬 수 있으므로 사용하지 않는 편이 좋음

```javascript
// 동등 비교. 결과를 예측하기 어렵다.
'0' == ''; // -> false
0 == '';   // -> true
0 == '0';  // -> true
false == 'false';   // -> false
false == '0';       // -> true
false == null;      // -> false
false == undefined; // -> false
```

- 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한해 true 반환
  - 암묵적 타입 변환 없음

```javascript
// 일치 비교
5 === 5; // -> true

// 암묵적 타입 변환을 하지 않고 값을 비교한다.
// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.
5 === '5'; // -> false
```

- 일치 비교 연산자에서는 NaN을 주의
- 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용해야 함

```javascript
// NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // -> false

// 빌트인 함수 isNaN은 주어진 값이 NaN인지 체크하고 그 결과를 반환한다.
isNaN(NaN); // -> true
isNaN(10);  // -> false
isNaN(1 + undefined); // -> true
```

- 숫자 0도 주의하도록 하자
  - 양의 0과 음의 0이 다름

```javascript
// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 true이다.
0 === -0; // -> true
0 == -0;  // -> true
```

- 부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대 개념

```javascript
// 부동등 비교
5 != 8;   // -> true
5 != 5;   // -> false
5 != '5'; // -> false

// 불일치 비교
5 !== 8;   // -> true
5 !== 5;   // -> false
5 !== '5'; // -> true
```

#### 7.2 대소 관계 비교 연산자

- 대소 관계 비교 연산자 : 피연산자의 크기를 비교하여 불리언 값 반환



### 8. 삼항 조건 연산자

- 삼항 조건 연산자(ternary operator) : 조건식의 평가 결과에 따라 반환할 값 결정
- 자바스크립트의 유일한 삼항 연산자이며 부수효과는 없음

```
조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값
```

- 물음표 앞의 첫번째 피연산자는 조건식(불리언 타입의 값으로 평가될 표현식)
- 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환
- 조건식이 참이면 콜론 앞의 두번째 피연산자가 평가되어 반환, 거짓이면 콜론 뒤의 세번째 피연산자가 평가되어 반환
- 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문
  - 다른 표현식의 일부가 될 수 있어 매우 유용

```javascript
var x = 2;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
// 삼항 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.
var result = x % 2 ? '홀수' : '짝수';

console.log(result); // 짝수
```

- 삼항 조건 연산자는 다음 장에서 살펴볼 if...else 문을 사용해도 동일한 처리를 할 수 있음

```javascript
var x = 2, result;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
if (x % 2) result = '홀수';
else       result = '짝수';

console.log(result); // 짝수
```

- if...else 문은 표현식이 아닌 문이므로 값처럼 사용할 수 없음

```javascript
var x = 10;

// if...else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.
var result = if (x % 2) { result = '홀수'; } else { result = '짝수'; };
// SyntaxError: Unexpected token if
```

- 조건에 따라 어떤 값을 결정해야 한다면 if...else 문보다 삼항 조건 연산자 표현식을 사용하는 것이 유리
  - 조건에 따라 수행해야 할 문이 여러개라면 if...else문을 사용하는 것이 가독성이 좋음



### 9. 논리 연산자

- 논리 연산자(Logical Operator) : 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산

| 논리 연산자 | 의미        | 부수 효과 |
| ----------- | ----------- | --------- |
| \|\|        | 논리합(OR)  | X         |
| &&          | 논리곱(AND) | X         |
| !           | 부정(NOT)   | X         |

- 논리 연산자는 언제나 불리언 값 반환
  - 피연산자가 반드시 불리언 값일 필요는 없음
  - 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환

```javascript
// 암묵적 타입 변환
!0;       // -> true
!'Hello'; // -> false
```

- 논리합 연산자와 논리곱 연산자의 연산 결과는 불리언 값이 아닐 수도 있음
  - 이 두 연산자는 언제나 피연산자 중 어느 한쪽 값을 반환

```javascript
// 단축 평가
'Cat' && 'Dog'; // -> 'Dog'
```

**드 모르간의 법칙**

- 논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아 한 눈에 이해하기 어려울 때가 있음
- [드 모르간의 법칙](https://ko.wikipedia.org/wiki/%EB%93%9C_%EB%AA%A8%EB%A5%B4%EA%B0%84%EC%9D%98_%EB%B2%95%EC%B9%99)을 활용하면 복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환할 수 있음

```javascript
!(x || y) === (!x && !y)
!(x && y) === (!x || !y)
```



### 10. 쉼표 연산자

- 쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과 반환

```javascript
var x, y, z;

x = 1, y = 2, z = 3; // 3
```



### 11. 그룹 연산자

- 그룹 연산자 ()는 피연산자인 표현식을 가장 먼저 평가

```javascript
10 * 2 + 3; // -> 23

// 그룹 연산자를 사용하여 우선 순위 조절
10 * (2 + 3); // -> 50
```



### 12. typeof 연산자

- typeof 연산자는 자신의 뒤에 위치한 피연산자의 데이터 값을 문자열로 반환
- typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 일치하지는 않음
- typeof 연산자는 7가지 문자열 중 하나를 반환하며 null을 반환하는 경우는 없고 함수의 경우 function을 반환
  - string, number, boolean, undefined, symbol, object, function

```javascript
typeof ''              // -> "string"
typeof 1               // -> "number"
typeof NaN             // -> "number"
typeof true            // -> "boolean"
typeof undefined       // -> "undefined"
typeof Symbol()        // -> "symbol"
typeof null            // -> "object"
typeof []              // -> "object"
typeof {}              // -> "object"
typeof new Date()      // -> "object"
typeof /test/gi        // -> "object"
typeof function () {}  // -> "function"
```

- typeof 연산자로 null 값을 연산해보면 "null"이 아닌 "object"를 반환하는 것에 주의
  - 자스크립트의 첫 번째 버전의 버그이나 기존 코드에 영향을 줄 수 있어 수정하지 못하고 있음

- null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용

```javascript
var foo = null;

typeof foo === null; // -> false
foo === null;        // -> true
```

- 선언하지 않은 식별자를 typeof 연산자로 연산해보면 ReferenceError가 발생하지 않고 "undefined"를 반환

```javascript
// 식별자 undeclared는 선언한 적이 없다.
typeof undeclared; // -> undefined
```

- typeof 연산자가 선언하지 않은 식별자를 연산했을 때 "undefined"를 반환하는 것을 카일 심슨의 "[You don't know JS](https://www.oreilly.com/library/view/you-dont-know/9781491905159/ch01.html)"에서는 특별한 안전 가드(safety guard)로 설명
  - 모던 자바스크립트 개발에서는 대부분 모듈을 사용하고 전역 변수인 플래그를 사용하지 않으므로 의도적으로 사용할 필요 없음



### 13. 지수 연산자

- ES7에서 새롭게 도입된 지수 연산자 : 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환
- 지수 연산자 도입 이전에는 Math. pow 메소드 사용

```javascript
5 ** 2;   // -> 25
5 ** 2.5; // -> 55.90169943749474
5 ** 0;   // -> 1
5 ** -2;  // -> 0.04

// 지수 연산자 도입 이전
Math.pow(5, 2);   // -> 25
Math.pow(5, 2.5); // -> 55.90169943749474
Math.pow(5, 0);   // -> 1
Math.pow(5, -2);  // -> 0.04
```

- 음수를 거듭제곱의 밑으로 계산하려면 괄호로 묶어야 함

```javascript
-5 ** 2;
// -> SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence
(-5) ** 2; // -> 25
```

- 지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 없음
- 지수 연산자는 모든 이항 연산자보다 우선 순위가 높음

```javascript
var num = 5;
num **= 2; // -> 25

// 우선순위
2 * 5 ** 2; // -> 50
```



모든 출처 : https://poiemaweb.com/